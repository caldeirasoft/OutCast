import kotlinx.datetime.Instant;
import kotlin.collections.List;

PRAGMA foreign_keys = 1;
CREATE TABLE queue (
    feedUrl TEXT NOT NULL,
    queueIndex INTEGER NOT NULL DEFAULT 0,
    guid TEXT NOT NULL,
    FOREIGN KEY (feedUrl, guid) REFERENCES `episode` (feedUrl, guid) ON DELETE CASCADE
);

CREATE TRIGGER insert_queue_update_index
BEFORE INSERT ON queue
BEGIN
    UPDATE queue SET queueIndex = queueIndex + 1
    WHERE queueIndex >= new.queueIndex;
END;

CREATE TRIGGER add_to_queue_remove_from_inbox
AFTER INSERT ON queue
BEGIN
    DELETE FROM inbox
     WHERE feedUrl = new.feedUrl AND guid = new.guid;
END;

CREATE TRIGGER insert_queue_last
AFTER INSERT ON queue
FOR EACH ROW WHEN (new.queueIndex == -1)
BEGIN
    REPLACE INTO queue (feedUrl, guid, queueIndex)
    SELECT new.feedUrl, new.guid, COUNT(*)
    FROM queue;
END;

CREATE TRIGGER delete_queue_update_index
AFTER DELETE ON queue
BEGIN
    UPDATE queue SET queueIndex = queueIndex - 1
    WHERE queueIndex > old.queueIndex;
END;

selectAll:
SELECT e.*
FROM episode AS e
INNER JOIN queue q USING (feedUrl, guid)
ORDER BY q.queueIndex;

addToQueueNext:
INSERT INTO queue (feedUrl, guid, queueIndex)
VALUES (?, ?, 0);

addToQueueLast:
INSERT INTO queue (feedUrl, guid, queueIndex)
VALUES (?, ?, -1);

addToQueue:
INSERT OR REPLACE INTO queue (feedUrl, guid, queueIndex)
VALUES (?, ?, ?);

removeFromQueue:
DELETE FROM queue
WHERE feedUrl = ? AND guid = ?;

updateQueueEpisodeLimit:
DELETE FROM queue
WHERE EXISTS (
    SELECT feedUrl, guid
    FROM episode
    WHERE (episode.feedUrl = queue.feedUrl AND episode.guid = queue.guid)
    AND feedUrl = :feedUrl
    ORDER BY releaseDateTime DESC
    LIMIT -1 OFFSET :offset
);

addRecentEpisodesIntoQueueFirst:
INSERT OR REPLACE INTO queue (feedUrl, guid, queueIndex)
SELECT e.feedUrl, guid, 0
FROM episode e
INNER JOIN podcast p ON (e.feedUrl = p.feedUrl)
WHERE p.feedUrl = :feedUrl
  AND e.releaseDateTime > :releaseDateTime;

addRecentEpisodesIntoQueueLast:
INSERT OR REPLACE INTO queue (feedUrl, guid, queueIndex)
SELECT e.feedUrl, guid, -1
FROM episode e
INNER JOIN podcast p ON (e.feedUrl = p.feedUrl)
WHERE p.feedUrl = :feedUrl
  AND e.releaseDateTime > :releaseDateTime;