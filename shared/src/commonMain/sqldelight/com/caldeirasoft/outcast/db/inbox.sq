import kotlinx.datetime.Instant;
import kotlin.collections.List;
import com.caldeirasoft.outcast.domain.models.Artwork;
import com.caldeirasoft.outcast.domain.models.Genre;

PRAGMA foreign_keys = 1;
CREATE TABLE inbox (
    feedUrl TEXT NOT NULL,
    guid TEXT NOT NULL,
    FOREIGN KEY (feedUrl, guid) REFERENCES `episode` (feedUrl, guid) ON DELETE CASCADE
);

selectAll:
SELECT e.*
FROM episode e
INNER JOIN inbox USING (feedUrl, guid)
ORDER BY e.releaseDateTime DESC;

addToInbox:
INSERT INTO inbox (feedUrl, guid)
VALUES (?, ?);

addMostRecentEpisodeToInbox:
INSERT OR REPLACE INTO inbox (feedUrl, guid)
SELECT e.feedUrl, e.guid
FROM episode e
INNER JOIN podcast p ON (e.feedUrl = p.feedUrl)
WHERE e.feedUrl = :feedUrl
  ORDER BY e.releaseDateTime DESC
LIMIT 1;

addRecentEpisodesIntoInbox:
INSERT OR REPLACE INTO inbox (feedUrl, guid)
SELECT e.feedUrl, e.guid
FROM episode e
INNER JOIN podcast p ON (e.feedUrl = p.feedUrl)
WHERE e.feedUrl = :feedUrl
  AND e.releaseDateTime > :releaseDateTime;

updateInboxEpisodeLimit:
DELETE FROM inbox
WHERE EXISTS (
    SELECT feedUrl, guid
    FROM episode
    WHERE (episode.feedUrl = inbox.feedUrl AND episode.guid = inbox.guid)
    AND feedUrl = :feedUrl
    ORDER BY releaseDateTime DESC
    LIMIT -1 OFFSET :offset
)
;

removeFromInbox:
DELETE FROM inbox
WHERE feedUrl = ? AND guid = ?;
