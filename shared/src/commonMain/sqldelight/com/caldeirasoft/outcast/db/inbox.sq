import kotlinx.datetime.Instant;
import kotlin.collections.List;
import com.caldeirasoft.outcast.domain.models.Artwork;
import com.caldeirasoft.outcast.domain.models.Genre;

PRAGMA foreign_keys = 1;
CREATE TABLE inbox (
    episodeId INTEGER NOT NULL UNIQUE PRIMARY KEY,
    FOREIGN KEY (`episodeId`) REFERENCES `episode` (`episodeId`) ON DELETE CASCADE
);

selectAll:
SELECT e.*
FROM episode e
INNER JOIN inbox USING (episodeId)
ORDER BY e.releaseDateTime DESC;

selectGenreId:
SELECT p.genreId
FROM episode e
INNER JOIN podcast p USING (podcastId)
INNER JOIN inbox USING (episodeId)
WHERE p.genreId IS NOT NULL;

selectEpisodesByGenreId:
SELECT e.*
FROM episode e
INNER JOIN podcast p USING (podcastId)
INNER JOIN inbox USING (episodeId)
WHERE p.genreId = :genreId
ORDER BY e.releaseDateTime DESC;

addToInbox:
INSERT INTO inbox (episodeId)
VALUES (?);

addMostRecentEpisodeToInbox:
INSERT OR REPLACE INTO inbox (episodeId)
SELECT episodeId
FROM episode e
INNER JOIN podcast p ON (e.podcastId = p.podcastId)
WHERE e.podcastId = :podcastId
  ORDER BY e.releaseDateTime DESC
LIMIT 1;

addRecentEpisodesIntoInbox:
INSERT OR REPLACE INTO inbox (episodeId)
SELECT episodeId
FROM episode e
INNER JOIN podcast p ON (e.podcastId = p.podcastId)
WHERE p.podcastId = :podcastId
  AND e.releaseDateTime > :releaseDateTime;

updateInboxEpisodeLimit:
DELETE FROM inbox
WHERE episodeId IN (
    SELECT episodeId
    FROM episode
    WHERE podcastId = ?
    ORDER BY releaseDateTime DESC
    LIMIT -1 OFFSET :offset
);

removeFromInbox:
DELETE FROM inbox
WHERE episodeId = :episodeId;
